# Claude Development Guide for {{PROJECT_NAME}}

This is a **full-stack application** built with **React + Python + NeonDB** and generated by the SupaEdge App Provisioning Service. This guide explains the development approach while maintaining the same clean architecture principles.

## 🏗️ Architecture Overview

### Project Structure
```
├── frontend/               # React frontend application
│   ├── core/              # ❌ NEVER MODIFY - React foundation
│   │   ├── lib/api.js     # API client with authentication
│   │   └── hooks/         # Core React hooks (useAuth, useDatabase)
│   └── app/               # ✅ MODIFY FREELY - React app code
│       ├── components/    # UI components for the app
│       ├── pages/         # App pages/routes  
│       ├── ui/            # App-specific styling
│       └── main.jsx       # App entry point
└── backend/               # Python FastAPI backend
    ├── core/              # ❌ NEVER MODIFY - Python foundation
    │   ├── auth.py        # JWT authentication system
    │   ├── database.py    # Database connection and setup
    │   ├── models.py      # Core SQLAlchemy models
    │   ├── routes.py      # Core API endpoints (auth, health)
    │   ├── services/      # Core business logic services
    │   └── generators/    # CRUD code generation system
    └── app/               # ✅ MODIFY FREELY - App-specific code
        ├── main_routes.py # App-specific API routes
        ├── services/      # App-specific business logic
        └── routes/generated/ # Auto-generated CRUD endpoints
```

### Technology Stack
- **Frontend**: React 18 with JSX (no TypeScript)
- **Backend**: Python FastAPI with async/await
- **Database**: NeonDB (PostgreSQL) with UUID primary keys
- **Authentication**: JWT tokens with httpOnly handling
- **Styling**: Tailwind CSS with modern design
- **State Management**: React Query for server state
- **Code Generation**: Python-based CRUD generation

## ⚙️ Environment Configuration

The project uses NeonDB with the following configuration:

### Backend Environment (backend/.env)
```env
# NeonDB Configuration
DATABASE_URL={{DATABASE_URL}}

# Security
SECRET_KEY={{SECRET_KEY}}

# Environment
ENVIRONMENT=development
```

### Frontend Environment (frontend/.env)
```env
# API Configuration
VITE_API_URL=https://{{PROJECT_NAME_SLUG}}-backend.onrender.com/api

# Development
NODE_ENV=development
```

## 👤 Demo User Setup

The project includes a pre-configured demo user:

### Demo Credentials
```
Email: demo@example.com
Password: demo123
```

### Demo Data
- **User**: Demo User with profile
- **Categories**: Work, Personal, Shopping (with colors and icons)
- **Todos**: 3 sample todos with different priorities and completion states

The database is fully set up with:
- Users and profiles tables
- Categories and todos tables with sample data
- Proper indexes and foreign key relationships
- Auto-update triggers for timestamps

## 🚀 Development Workflow

### 1. Starting Development

**Terminal 1 - Backend**:
```bash
cd backend
uvicorn main:app --reload --port 8000
```

**Terminal 2 - Frontend**:
```bash
cd frontend
npm run dev
```

Visit `http://localhost:3000` and sign in with demo credentials.

### 2. Adding New Features

#### Step 1: Database Schema
Create new tables in NeonDB:
```sql
CREATE TABLE projects (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name VARCHAR NOT NULL,
  description TEXT,
  status VARCHAR DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add trigger for updated_at
CREATE TRIGGER update_projects_updated_at 
  BEFORE UPDATE ON projects 
  FOR EACH ROW 
  EXECUTE FUNCTION update_updated_at_column();
```

#### Step 2: Configure Code Generation
Update `backend/core/generators/codegen.config.json`:
```json
{
  "tables": [
    {"table": "todos", "primaryKey": "id"},
    {"table": "categories", "primaryKey": "id"},
    {"table": "projects", "primaryKey": "id"}
  ]
}
```

#### Step 3: Generate CRUD Code
From the frontend directory:
```bash
cd frontend
npm run generate:crud
```

This creates:
- `backend/app/services/generated/projects_service.py`
- `backend/app/routes/generated/projects_routes.py`

#### Step 4: Include Routes
Add to `backend/app/main_routes.py`:
```python
from .routes.generated.projects_routes import router as projects_router
router.include_router(projects_router, tags=["projects"])
```

#### Step 5: Create React Components
```jsx
// frontend/app/components/ProjectCard.jsx
import React from 'react'
import { useCRUD } from '@core'

export default function ProjectCard() {
  const { 
    data: projects, 
    loading, 
    create, 
    update, 
    delete: deleteProject 
  } = useCRUD('projects')
  
  if (loading) return <div>Loading...</div>
  
  return (
    <div className="space-y-4">
      {projects.map(project => (
        <div key={project.id} className="bg-white p-4 rounded-lg shadow">
          <h3 className="text-lg font-medium">{project.name}</h3>
          <p className="text-gray-600">{project.description}</p>
          <div className="mt-2 flex space-x-2">
            <button 
              onClick={() => update({ id: project.id, data: { status: 'completed' } })}
              className="btn-primary"
            >
              Complete
            </button>
            <button 
              onClick={() => deleteProject(project.id)}
              className="btn-danger"
            >
              Delete
            </button>
          </div>
        </div>
      ))}
    </div>
  )
}
```

### 3. Page Creation
```jsx
// frontend/app/pages/ProjectsPage.jsx
import React, { useState } from 'react'
import { useCRUD } from '@core'
import ProjectCard from '../components/ProjectCard'

export default function ProjectsPage() {
  const [isCreating, setIsCreating] = useState(false)
  const { create, creating } = useCRUD('projects')
  
  const handleCreate = async (data) => {
    await create(data)
    setIsCreating(false)
  }
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Projects</h1>
        <button 
          onClick={() => setIsCreating(true)}
          className="btn-primary"
        >
          Add Project
        </button>
      </div>
      
      <ProjectCard />
      
      {/* Create form modal/component */}
    </div>
  )
}
```

### 4. Routing Update
Add to `frontend/app/main.jsx`:
```jsx
import ProjectsPage from './pages/ProjectsPage'

// In the Routes component:
<Route 
  path="/projects" 
  element={
    <ProtectedRoute>
      <Layout>
        <ProjectsPage />
      </Layout>
    </ProtectedRoute>
  } 
/>
```

## 📁 Code Organization

### Backend Structure
```python
# Services pattern
class ProjectsService:
    async def create(self, data: Dict[str, Any]) -> Dict[str, Any]:
        return await self.db_service.create(self.table, data)
    
    async def get_all(self, user_id: str) -> List[Dict[str, Any]]:
        return await self.db_service.get_all(self.table, user_id)

# Routes pattern  
@router.post("/projects")
async def create_project(
    data: Dict[str, Any],
    current_user: Dict[str, Any] = Depends(get_current_user),
    db: Database = Depends(get_db_connection)
):
    service = get_projects_service(db)
    data["user_id"] = current_user["id"]
    return await service.create(data)
```

### Frontend Patterns
```jsx
// Hook usage pattern
const { data, loading, error, create, update, delete } = useCRUD('projects')

// Component pattern
export default function ProjectComponent() {
  // State management
  // Event handlers  
  // Render JSX
}

// API integration
import { apiClient } from '@core'
const data = await apiClient.get('/app/projects')
```

## 🎯 Code Generation Benefits

### Automatic CRUD Generation
Running `npm run generate:crud` (from frontend directory) creates:

1. **Backend Service** (`projects_service.py`):
   - Full CRUD operations
   - Type hints and validation
   - User isolation (user_id filtering)
   - Error handling

2. **Backend Routes** (`projects_routes.py`):
   - RESTful endpoints
   - Authentication middleware
   - Request validation
   - Response formatting

3. **Frontend Integration**:
   - Use `useCRUD('projects')` hook
   - Automatic React Query integration
   - Optimistic updates
   - Error handling

### Generated API Endpoints
```
POST   /api/app/projects       # Create project
GET    /api/app/projects       # Get user's projects  
GET    /api/app/projects/{id}  # Get specific project
PUT    /api/app/projects/{id}  # Update project
DELETE /api/app/projects/{id}  # Delete project
```

## 🔧 Database Patterns

### Table Structure
```sql
-- Standard table pattern
CREATE TABLE your_table (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  -- your columns here
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Trigger for auto-updates
CREATE TRIGGER update_your_table_updated_at 
  BEFORE UPDATE ON your_table 
  FOR EACH ROW 
  EXECUTE FUNCTION update_updated_at_column();
```

### User Isolation
All app tables should include `user_id` for proper data isolation:
- Generated services automatically filter by user_id
- Generated routes enforce authentication
- No cross-user data access

## 🚫 What NOT to Do

### ❌ Don't Modify Core
- Never edit files in `frontend/core/` or `backend/core/`
- Don't duplicate authentication logic
- Don't bypass the generated CRUD patterns

### ❌ Don't Skip Code Generation
- Always use the generator for new tables
- Don't write manual CRUD endpoints
- Don't ignore the established patterns

### ❌ Don't Hardcode Values
- Use environment variables
- Follow the configuration patterns
- Keep secrets in .env files

## ✅ Best Practices

### 🎯 Use Generated Code
```jsx
// ✅ Good - Use generated CRUD
const { data, create, update, delete } = useCRUD('projects')

// ❌ Bad - Manual API calls
const [data, setData] = useState([])
useEffect(() => {
  fetch('/api/projects').then(r => r.json()).then(setData)
}, [])
```

### 🎯 Follow Architecture
```python
# ✅ Good - Use dependency injection
async def create_project(
    data: Dict[str, Any],
    current_user: Dict[str, Any] = Depends(get_current_user),
    db: Database = Depends(get_db_connection)
):
    service = get_projects_service(db)
    return await service.create(data)

# ❌ Bad - Direct database access
async def create_project(data: Dict[str, Any]):
    # Direct SQL execution
```

### 🎯 Use Type Safety
```python
# ✅ Good - Type hints
async def create(self, data: Dict[str, Any]) -> Dict[str, Any]:
    return await self.db_service.create(self.table, data)

# ❌ Bad - No types
async def create(self, data):
    return await self.db_service.create(self.table, data)
```

## 🚀 Deployment

### Render.com Setup
1. Connect GitHub repository to Render
2. Render automatically deploys both frontend and backend
3. Set `DATABASE_URL` in Render dashboard
4. Other environment variables are auto-configured

### Environment Variables
- **Backend**: `DATABASE_URL`, `SECRET_KEY`, `ENVIRONMENT`
- **Frontend**: `VITE_API_URL` (auto-set to backend URL)

## 📊 Included Demo Features

The boilerplate includes a complete todo application:

### Authentication
- JWT-based login/register
- Protected routes
- User session management

### Dashboard
- Real-time statistics
- User-specific data
- Feature showcase

### Todo Management  
- CRUD operations
- Priority levels
- Categories
- Due dates
- Completion tracking

### Modern UI
- Tailwind CSS styling
- Responsive design
- Loading states
- Error handling
- Form validation

## 🎯 Summary

1. **Never modify `core/`** - it's the reusable foundation
2. **Use code generation** - `cd frontend && npm run generate:crud` for new tables
3. **Follow the patterns** - services, hooks, components
4. **Maintain user isolation** - always include user_id in tables
5. **Use type safety** - leverage Python type hints and JSX patterns
6. **Test thoroughly** - verify auth, CRUD operations, and UI flows

### Quick Development Checklist
- [ ] Create database table with proper structure
- [ ] Add to `backend/core/generators/codegen.config.json`
- [ ] Run `cd frontend && npm run generate:crud`
- [ ] Include routes in `backend/app/main_routes.py`
- [ ] Create React components using `useCRUD`
- [ ] Add to routing in `frontend/app/main.jsx`
- [ ] Test the complete flow

This architecture ensures rapid development while maintaining clean separation of concerns and type safety across the full stack.
